// Code generated by hertz generator.

package student

import (
	"bytes"
	"context"
	"encoding/json"
	"github.com/cloudwego/kitex/client"
	"github.com/cloudwego/kitex/client/genericclient"
	"github.com/cloudwego/kitex/pkg/connpool"
	"github.com/cloudwego/kitex/pkg/generic"
	"github.com/cloudwego/kitex/pkg/klog"
	"github.com/cloudwego/kitex/pkg/loadbalance"
	etcd "github.com/kitex-contrib/registry-etcd"
	"main/hz/biz/model/student"
	_ "main/hz/biz/model/student"
	"net/http"
	"sync"

	"log"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

var path = "/Users/xiaofeng/workplace_go/Go-learning/api_gateway/idl/student.thrift" // depends on current directory
var url = "http://localhost:8888"
var clientCache = sync.Map{}

func getErrorBizResponse(code int32, msg string) *student.Response {
	return &student.Response{
		Code: code,
		Msg:  msg,
		Data: "",
	}
}

func getClient() genericclient.Client {
	// 标明注册中心地址
	resolver, err := etcd.NewEtcdResolver([]string{"http://127.0.0.1:2379"})
	// 配置客户端
	var opts []client.Option
	opts = append(opts,
		client.WithLongConnection(connpool.IdleConfig{MinIdlePerAddress: 10, MaxIdlePerAddress: 1000}),
		client.WithResolver(resolver),
		client.WithLoadBalancer(loadbalance.NewWeightedRandomBalancer()),
	)
	p, err := generic.NewThriftFileProvider(path)
	if err != nil {
		klog.Fatalf("new thrift file provider failed: %v", err)
	}
	g, err := generic.HTTPThriftGeneric(p)
	if err != nil {
		log.Fatal(err)
	}
	studentCli, err := genericclient.NewClient("studentService", g, opts...)
	if err != nil {
		log.Fatal(err)
	}
	return studentCli
}

// AddStudent .
// @router /add-student-info [POST]
func AddStudent(ctx context.Context, c *app.RequestContext) {
	var cli genericclient.Client
	cli_, ok := clientCache.Load("addStudent")
	if !ok {
		cli = getClient()
		clientCache.Store("queryStudent", cli)
	}
	cli = cli_.(genericclient.Client)
	var err error
	var saveStudentRequest student.SaveStudentReq
	err = c.BindAndValidate(&saveStudentRequest)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	body := map[string]interface{}{
		"studentNo":   saveStudentRequest.StudentNo,
		"studentName": saveStudentRequest.StudentName,
	}
	data, err := json.Marshal(body)
	if err != nil {
		klog.Fatalf("body marshal failed: %v", err)
		c.JSON(consts.StatusInternalServerError, nil)
	}
	req, err := http.NewRequest(http.MethodPost, url+"/add-student-info", bytes.NewBuffer(data))
	if err != nil {
		klog.Fatalf("new http request failed: %v", err)
		c.JSON(consts.StatusInternalServerError, nil)
	}
	customReq, err := generic.FromHTTPRequest(req)
	if err != nil {
		klog.Fatalf("convert request failed: %v", err)
		c.JSON(consts.StatusInternalServerError, nil)
	}
	resp, err := cli.GenericCall(context.Background(), "", customReq)
	if err != nil {
		klog.Fatalf("generic call failed: %v", err)
		c.JSON(consts.StatusInternalServerError, nil)
	}
	realResp := resp.(*generic.HTTPResponse)
	klog.Infof("method2 response, status code: %v, headers: %v, body: %v\n", realResp.StatusCode, realResp.Header, realResp.Body)
	c.JSON(consts.StatusOK, realResp.Body)
}

// QueryStudent .
// @router /query [GET]
func QueryStudent(ctx context.Context, c *app.RequestContext) {
	var cli genericclient.Client
	cli_, ok := clientCache.Load("queryStudent")
	if !ok {
		cli = getClient()
		clientCache.Store("queryStudent", cli)
	}
	cli = cli_.(genericclient.Client)
	var err error
	var queryStudentRequest student.QueryStudentReq
	err = c.BindAndValidate(&queryStudentRequest)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	body := map[string]interface{}{
		"studentNo": queryStudentRequest.StudentNo,
	}
	data, err := json.Marshal(body)
	if err != nil {
		klog.Fatalf("body marshal failed: %v", err)
		c.JSON(consts.StatusInternalServerError, getErrorBizResponse(consts.StatusInternalServerError, err.Error()))
	}
	req, err := http.NewRequest(http.MethodGet, url+"/query", bytes.NewBuffer(data))
	if err != nil {
		klog.Fatalf("new http request failed: %v", err)
		c.JSON(consts.StatusInternalServerError, getErrorBizResponse(consts.StatusInternalServerError, err.Error()))
	}
	customReq, err := generic.FromHTTPRequest(req)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, getErrorBizResponse(consts.StatusInternalServerError, err.Error()))
	}
	resp, err := cli.GenericCall(context.Background(), "", customReq)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, getErrorBizResponse(consts.StatusInternalServerError, err.Error()))
	}
	realResp := resp.(*generic.HTTPResponse)
	klog.Infof("method1 response, status code: %v, headers: %v, body: %v\n", realResp.StatusCode, realResp.Header, realResp.Body)
	c.JSON(consts.StatusOK, realResp.Body)
}

// QueryStudent2 .
// @router /query2 [GET]
func QueryStudent2(ctx context.Context, c *app.RequestContext) {
	cli := getClient()
	var err error
	var queryStudentRequest student.QueryStudentReq
	err = c.BindAndValidate(&queryStudentRequest)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	body := map[string]interface{}{
		"studentNo": queryStudentRequest.StudentNo,
	}
	data, err := json.Marshal(body)
	if err != nil {
		klog.Fatalf("body marshal failed: %v", err)
		c.JSON(consts.StatusInternalServerError, getErrorBizResponse(consts.StatusInternalServerError, err.Error()))
	}
	req, err := http.NewRequest(http.MethodGet, url+"/query", bytes.NewBuffer(data))
	if err != nil {
		klog.Fatalf("new http request failed: %v", err)
		c.JSON(consts.StatusInternalServerError, getErrorBizResponse(consts.StatusInternalServerError, err.Error()))
	}
	customReq, err := generic.FromHTTPRequest(req)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, getErrorBizResponse(consts.StatusInternalServerError, err.Error()))
	}
	resp, err := cli.GenericCall(context.Background(), "", customReq)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, getErrorBizResponse(consts.StatusInternalServerError, err.Error()))
	}
	realResp := resp.(*generic.HTTPResponse)
	klog.Infof("method1 response, status code: %v, headers: %v, body: %v\n", realResp.StatusCode, realResp.Header, realResp.Body)
	c.JSON(consts.StatusOK, realResp.Body)
}
